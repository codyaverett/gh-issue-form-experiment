/**
 * GitHub Issue Form Body Parser
 *
 * Parses the markdown body generated by GitHub Issue Forms into structured JSON.
 * Issue forms generate predictable markdown with H3 headers (### Field Label)
 * followed by the user's response.
 *
 * Usage:
 *   const parser = require('./parse-issue-form.js');
 *   const formData = parser.parseIssueBody(issueBody);
 */

/**
 * Convert a header string to camelCase key
 * @param {string} str - The header string to convert
 * @returns {string} - camelCase version of the string
 */
function toCamelCase(str) {
  return str
    .toLowerCase()
    .replace(/[^a-z0-9\s]/g, '')  // Remove special characters
    .trim()
    .replace(/\s+(.)/g, (_, c) => c.toUpperCase())  // Capitalize after spaces
    .replace(/^\w/, c => c.toLowerCase());  // Ensure first char is lowercase
}

/**
 * Parse the content of a form field based on its format
 * @param {string} content - The raw content from the form field
 * @returns {*} - Parsed content (string, array, object, or null)
 */
function parseContent(content) {
  // Empty or no response
  if (!content || content.trim() === '' || content.trim() === '_No response_') {
    return null;
  }

  const trimmed = content.trim();

  // Checkbox list: lines starting with - [X] or - [ ]
  if (/^- \[[ xX]\]/m.test(trimmed)) {
    return trimmed
      .split('\n')
      .filter(line => /^- \[[ xX]\]/.test(line.trim()))
      .map(line => {
        const isChecked = /^- \[[xX]\]/.test(line.trim());
        const label = line.trim().replace(/^- \[[ xX]\]\s*/, '');
        return { label, checked: isChecked };
      });
  }

  // Code block: ```language ... ```
  if (trimmed.startsWith('```')) {
    const match = trimmed.match(/^```(\w*)\n?([\s\S]*?)\n?```$/);
    if (match) {
      return {
        language: match[1] || 'text',
        code: match[2].trim()
      };
    }
    // Fallback: return content without backticks
    return trimmed.replace(/^```\w*\n?/, '').replace(/\n?```$/, '');
  }

  // Multi-line dropdown (multiple selections are comma-separated on one line)
  // But also could be multiple lines for checkboxes - handled above
  // Check if it's a comma-separated list (dropdown with multiple: true)
  if (trimmed.includes(', ') && !trimmed.includes('\n')) {
    return trimmed.split(', ').map(s => s.trim()).filter(Boolean);
  }

  // Plain text (could be single line or multi-line)
  return trimmed;
}

/**
 * Parse the full issue body into a structured object
 * @param {string} body - The raw issue body markdown
 * @returns {Object} - Parsed form data as key-value pairs
 */
function parseIssueBody(body) {
  const result = {};

  if (!body) {
    return result;
  }

  // Split by H3 headers (### Field Label)
  // The regex splits on ### at the start of a line
  const sections = body.split(/^### /gm).filter(Boolean);

  for (const section of sections) {
    const lines = section.split('\n');
    const header = lines[0].trim();

    // Skip empty headers
    if (!header) continue;

    // Join remaining lines as content
    const content = lines.slice(1).join('\n');

    // Convert header to camelCase key
    const key = toCamelCase(header);

    // Skip if key is empty
    if (!key) continue;

    // Parse and store the content
    result[key] = parseContent(content);
  }

  return result;
}

/**
 * Extract workflow context from parsed form data
 * @param {Object} formData - Parsed form data
 * @returns {Object} - Workflow context with id and step
 */
function extractWorkflowContext(formData) {
  const contextValue = formData.workflowContext;

  if (!contextValue || typeof contextValue !== 'string') {
    return { workflowId: null, stepNumber: 0 };
  }

  const parts = contextValue.split(':');
  return {
    workflowId: parts[0] || null,
    stepNumber: parseInt(parts[1] || '0', 10)
  };
}

/**
 * Determine the form type based on labels or content
 * @param {string[]} labels - Issue labels
 * @param {Object} formData - Parsed form data
 * @returns {string} - Form type identifier
 */
function determineFormType(labels, formData) {
  if (labels.includes('deployment')) return 'deployment';
  if (labels.includes('approval')) return 'approval';

  // Fallback: check for key fields
  if (formData.applicationName || formData.appName) return 'deployment';
  if (formData.approvalDecision) return 'approval';

  return 'unknown';
}

/**
 * Validate required fields for a form type
 * @param {string} formType - The type of form
 * @param {Object} formData - Parsed form data
 * @returns {Object} - Validation result with isValid and errors
 */
function validateFormData(formType, formData) {
  const errors = [];

  if (formType === 'deployment') {
    if (!formData.applicationName) errors.push('Application Name is required');
    if (!formData.targetEnvironment && !formData.environment) errors.push('Target Environment is required');
    if (!formData.versionTag && !formData.version) errors.push('Version/Tag is required');
  }

  if (formType === 'approval') {
    if (!formData.workflowContext) errors.push('Workflow Context is required for approvals');
    if (!formData.approvalDecision) errors.push('Approval Decision is required');
  }

  return {
    isValid: errors.length === 0,
    errors
  };
}

/**
 * Serialize form data for passing to workflow_dispatch
 * Handles the 65KB limit by truncating if necessary
 * @param {Object} formData - Parsed form data
 * @param {number} maxLength - Maximum length in characters (default 60000)
 * @returns {string} - JSON string
 */
function serializeForWorkflow(formData, maxLength = 60000) {
  let json = JSON.stringify(formData);

  if (json.length <= maxLength) {
    return json;
  }

  // If too large, try removing large text fields
  const trimmed = { ...formData };
  const largeFields = ['notes', 'additionalNotes', 'customAnnotations', 'envVars', 'environmentVariables'];

  for (const field of largeFields) {
    if (trimmed[field] && json.length > maxLength) {
      if (typeof trimmed[field] === 'string') {
        trimmed[field] = trimmed[field].substring(0, 500) + '... [truncated]';
      } else if (trimmed[field].code) {
        trimmed[field].code = trimmed[field].code.substring(0, 500) + '... [truncated]';
      }
      json = JSON.stringify(trimmed);
    }
  }

  return json;
}

// Export functions for use in workflows
module.exports = {
  parseIssueBody,
  parseContent,
  toCamelCase,
  extractWorkflowContext,
  determineFormType,
  validateFormData,
  serializeForWorkflow
};

// CLI usage: node parse-issue-form.js < issue-body.md
if (require.main === module) {
  let input = '';
  process.stdin.setEncoding('utf8');
  process.stdin.on('readable', () => {
    let chunk;
    while ((chunk = process.stdin.read()) !== null) {
      input += chunk;
    }
  });
  process.stdin.on('end', () => {
    const result = parseIssueBody(input);
    console.log(JSON.stringify(result, null, 2));
  });
}
